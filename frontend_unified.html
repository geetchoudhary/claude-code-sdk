<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Claude Code Unified Dashboard</title>
    
    <!-- Import Google Fonts -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600&family=Instrument+Serif:ital,wght@0,400;1,400&display=swap" rel="stylesheet">
    
    <!-- Firebase App (the core Firebase SDK) is always required and must be listed first -->
    <script type="module">
        // Import the functions you need from the SDKs you need
        import { initializeApp } from "https://www.gstatic.com/firebasejs/10.7.1/firebase-app.js";
        import { getAnalytics } from "https://www.gstatic.com/firebasejs/10.7.1/firebase-analytics.js";
        // TODO: Add SDKs for Firebase products that you want to use
        // https://firebase.google.com/docs/web/setup#available-libraries

        // Your web app's Firebase configuration
        // For Firebase JS SDK v7.20.0 and later, measurementId is optional
        const firebaseConfig = {
          apiKey: "AIzaSyBrWfN4B9bgRUHNysxA9dkRq81H0Uf3I88",
          authDomain: "tgsd-test.firebaseapp.com",
          projectId: "tgsd-test",
          storageBucket: "tgsd-test.firebasestorage.app",
          messagingSenderId: "369485316157",
          appId: "1:369485316157:web:13c3a9ca7d96215352aa54",
          measurementId: "G-C4J0YE2DZ0"
        };

        // Initialize Firebase
        const app = initializeApp(firebaseConfig);
        const analytics = getAnalytics(app);
        
        // Make Firebase available globally
        window.firebaseApp = app;
        window.firebaseAnalytics = analytics;
        
        console.log('Firebase initialized successfully');
    </script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: 'Inter', -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: linear-gradient(180deg, #ffffff 0%, #f8f9fa 100%);
            color: #5d6588;
            line-height: 1.6;
            margin: 0;
            padding: 0;
            min-height: 100vh;
        }
        
        .container {
            max-width: 375px;
            margin: 0 auto;
            padding: 20px 18px;
            min-height: 100vh;
            background: linear-gradient(180deg, #ffffff 0%, #f8f9fa 100%);
            position: relative;
        }
        

        
        /* Greeting Header Styles */
        .greeting-header {
            text-align: center;
            margin: 40px 0 60px 0;
        }
        
        .greeting-title {
            font-family: 'Instrument Serif', serif;
            font-size: 42px;
            font-weight: 400;
            line-height: 45px;
            color: #3159c8;
            margin: 0 0 20px 0;
            letter-spacing: -2px;
            display: block;
        }
        
        .question-counter {
            font-family: 'Inter', sans-serif;
            font-size: 16px;
            font-weight: 400;
            color: #7a8db5;
            margin: 0;
            letter-spacing: -0.48px;
        }
        
        .main-content {
            display: flex;
            flex-direction: column;
            gap: 20px;
        }
        
        .section {
            background: #fff;
            padding: 20px;
            border-radius: 10px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
        }
        
        .section h2, h1, h2, h3 {
            color: #2c3e50;
            margin-bottom: 15px;
            display: flex;
            align-items: center;
            gap: 10px;
        }
        
        /* Session Styles */
        .new-session-section {
            background: #ffffff;
            border-radius: 10px;
            box-shadow: 0px 1px 1px 0px rgba(0,0,0,0.07),
                        0px 2px 2px 0px rgba(0,0,0,0.07),
                        0px 4px 4px 0px rgba(0,0,0,0.07),
                        0px 8px 8px 0px rgba(0,0,0,0.07),
                        0px 16px 16px 0px rgba(0,0,0,0.07);
            margin-bottom: 20px;
            overflow: hidden;
        }
        
        .new-session-section h3 {
            background: #f6f7f9;
            margin: 0;
            padding: 14px 10px;
            border: 2px solid #ffffff;
            border-radius: 10px 10px 0 0;
            font-family: 'Inter', sans-serif;
            font-size: 14px;
            font-weight: 500;
            color: #4d5a73;
            display: flex;
            align-items: center;
            gap: 6px;
            letter-spacing: -0.42px;
        }
        
        .new-session-section h3::before {
            content: "💡";
            font-size: 13px;
        }
        
        .new-session-content {
            background: #ffffff;
            padding: 15px 20px 20px 15px;
            border-radius: 0 0 10px 10px;
        }
        
        .permission-mode-section {
            margin-bottom: 20px;
        }
        
        .permission-mode-section label {
            font-family: 'Inter', sans-serif;
            font-size: 13px;
            font-weight: 500;
            color: #5d6588;
            margin-bottom: 8px;
            display: block;
            letter-spacing: -0.39px;
        }
        
        .permission-mode-section select {
            width: 100%;
            padding: 10px;
            border: 1px solid #d5d5d5;
            border-radius: 6px;
            font-family: 'Inter', sans-serif;
            font-size: 14px;
            color: #5d6588;
            background: #ffffff;
            box-shadow: 0px 1px 1px 0px rgba(0,0,0,0.07),
                        0px 2px 2px 0px rgba(0,0,0,0.07),
                        0px 4px 4px 0px rgba(101,101,101,0.07),
                        0px 8px 8px 0px rgba(77,77,77,0.07);
        }
        
        .new-session-input {
            display: flex;
            gap: 10px;
            align-items: stretch;
            margin-top: 20px;
        }
        
        .new-session-input textarea {
            flex: 1;
            padding: 12px 15px;
            border: 1px solid #d5d5d5;
            border-radius: 6px;
            font-family: 'Inter', sans-serif;
            font-size: 14px;
            resize: none;
            min-height: 39px;
            max-height: 120px;
            color: #5d6588;
            background: #ffffff;
            box-shadow: 0px 1px 1px 0px rgba(0,0,0,0.07),
                        0px 2px 2px 0px rgba(0,0,0,0.07),
                        0px 4px 4px 0px rgba(101,101,101,0.07),
                        0px 8px 8px 0px rgba(77,77,77,0.07);
            letter-spacing: -0.28px;
            overflow-y: auto;
            overflow-x: hidden;
            line-height: 1.5;
        }
        
        .new-session-input textarea::placeholder {
            background: linear-gradient(90deg, #7a8db5 0%, #f2f6ff 100%);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }
        
        .session-content-direct {
            margin-bottom: 20px;
        }
        
        .session-content-direct .session-input-area {
            padding: 15px 20px 20px 15px;
            background: #ffffff;
            border-radius: 0 0 10px 10px;
            display: none; /* Hide the old input area */
        }
        
        .session-content-direct textarea {
            width: 100%;
            padding: 12px 15px;
            border: 1px solid #d5d5d5;
            border-radius: 6px;
            font-family: 'Inter', sans-serif;
            font-size: 14px;
            resize: vertical;
            min-height: 39px;
            color: #5d6588;
            background: #ffffff;
            box-shadow: 0px 1px 1px 0px rgba(0,0,0,0.07),
                        0px 2px 2px 0px rgba(0,0,0,0.07),
                        0px 4px 4px 0px rgba(101,101,101,0.07),
                        0px 8px 8px 0px rgba(77,77,77,0.07);
            letter-spacing: -0.28px;
            margin-bottom: 10px;
        }
        
        .session-content-direct textarea::placeholder {
            background: linear-gradient(90deg, #7a8db5 0%, #f2f6ff 100%);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }
        
        .message {
            padding: 15px;
            margin-bottom: 15px;
            border-radius: 5px;
            background: #f8f9fa;
        }
        
        /* Button Styles */
        .btn {
            padding: 10px 20px;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            font-size: 14px;
            font-weight: bold;
            transition: all 0.2s;
        }
        
        .btn-primary {
            background: #3498db;
            color: white;
        }
        
        .btn-primary:hover {
            background: #2980b9;
        }
        
        .btn-success {
            background: #3159c8;
            color: white;
            padding: 12px 20px;
            border: none;
            border-radius: 6px;
            font-family: 'Inter', sans-serif;
            font-size: 14px;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.2s;
            letter-spacing: -0.28px;
        }
        
        .btn-success:hover {
            background: #2847b8;
        }
        
        .btn-danger {
            background: #e74c3c;
            color: white;
        }
        
        .btn-danger:hover {
            background: #c0392b;
        }
        
        .btn-secondary {
            background: #95a5a6;
            color: white;
        }
        
        .btn-secondary:hover {
            background: #7f8c8d;
        }
        
        .btn:disabled {
            background: #95a5a6;
            cursor: not-allowed;
        }
        
        /* Status Badges */
        .status-badge {
            padding: 5px 10px;
            border-radius: 20px;
            font-size: 12px;
            font-weight: bold;
            text-transform: uppercase;
        }
        
        .status-badge.completed {
            background: #d4edda;
            color: #155724;
        }
        
        .status-badge.failed {
            background: #f8d7da;
            color: #721c24;
        }
        
        .empty-state {
            text-align: center;
            color: #999;
            padding: 40px;
        }
        
        .notification {
            position: fixed;
            top: 20px;
            right: 20px;
            padding: 15px 20px;
            background: #333;
            color: white;
            border-radius: 5px;
            box-shadow: 0 4px 6px rgba(0,0,0,0.1);
            animation: slideInRight 0.3s ease-out;
            z-index: 1000;
        }
        
        @keyframes slideInRight {
            from {
                opacity: 0;
                transform: translateX(100%);
            }
            to {
                opacity: 1;
                transform: translateX(0);
            }
        }
        
        .notification.success {
            background: #27ae60;
        }
        
        .notification.warning {
            background: #ff9800;
        }
        
        .notification.error {
            background: #e74c3c;
        }
        
        /* Message type specific styles */
        .user-message {
            animation: slideInFromLeft 0.3s ease-out;
        }
        
        .claude-processing {
            animation: slideInFromRight 0.3s ease-out;
        }
        
        .claude-completed {
            animation: slideInFromRight 0.3s ease-out;
        }
        
        @keyframes slideInFromLeft {
            from {
                opacity: 0;
                transform: translateX(-20px);
            }
            to {
                opacity: 1;
                transform: translateX(0);
            }
        }
        
        @keyframes slideInFromRight {
            from {
                opacity: 0;
                transform: translateX(20px);
            }
            to {
                opacity: 1;
                transform: translateX(0);
            }
        }
        
        /* Blinking animation for processing indicator */
        .thinking-indicator {
            animation: blink 1.5s infinite;
        }
        
        @keyframes blink {
            0%, 50% { opacity: 1; }
            51%, 100% { opacity: 0.3; }
        }
        
        /* ===== NEW MESSAGE CARD REDESIGN STYLES ===== */
        .message-card-redesign {
            background: #ffffff;
            border-radius: 12px;
            border: 1px solid #e5e7eb;
            box-shadow: 0 1px 3px 0 rgba(0, 0, 0, 0.1), 0 1px 2px 0 rgba(0, 0, 0, 0.06);
            margin-bottom: 20px;
            overflow: hidden;
            animation: slideIn 0.3s ease-out;
            flex-shrink: 0;
            transition: transform 0.3s ease, opacity 0.3s ease, box-shadow 0.3s ease;
        }
        
        /* Horizontal scrollable container styles */
        .horizontal-cards-container {
            display: flex;
            overflow-x: auto;
            overflow-y: hidden;
            gap: 15px;
            padding: 20px 0;
            scroll-behavior: smooth;
            -webkit-overflow-scrolling: touch;
            position: relative;
            scrollbar-width: none; /* Firefox */
            -ms-overflow-style: none; /* IE and Edge */
        }
        
        /* Hide scrollbar for Chrome, Safari and Opera */
        .horizontal-cards-container::-webkit-scrollbar {
            display: none;
        }
        
        .message-card-wrapper {
            display: flex;
            flex-direction: column;
            width: calc(100vw - 56px);
            max-width: 375px;
            min-width: 340px;
            height: fit-content;
            position: relative;
        }
        
        .message-card-wrapper.active {
            width: calc(100vw - 56px);
            max-width: 375px;
            min-width: 340px;
        }
        
        .message-card-wrapper .message-card-redesign {
            margin-bottom: 0;
            height: 100%;
            display: flex;
            flex-direction: column;
        }
        
        .message-card-wrapper.inactive {
            opacity: 0.7;
            transform: scale(0.95);
        }
        
        .message-card-wrapper.active .message-card-redesign {
            border-color: #d1d5db;
            box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1), 0 2px 4px -1px rgba(0, 0, 0, 0.06);
        }
        
        /* Input section for active card */
        .card-input-section {
            background: #f8f9fa;
            border-top: 1px solid #e9ecef;
            padding: 15px;
            margin-top: 15px;
            display: none;
        }
        
        .message-card-wrapper.active .card-input-section {
            display: block;
        }
        
        .card-input-wrapper {
            display: flex;
            gap: 10px;
            align-items: flex-end;
        }
        
        .card-input-wrapper textarea {
            flex: 1;
            padding: 10px 12px;
            border: 1px solid #d5d5d5;
            border-radius: 6px;
            font-family: 'Inter', sans-serif;
            font-size: 14px;
            resize: none;
            min-height: 40px;
            max-height: 120px;
            color: #5d6588;
            background: #ffffff;
            overflow-y: auto;
            overflow-x: hidden;
            line-height: 1.5;
        }
        
        .card-input-wrapper button {
            padding: 10px 16px;
            background: #3159c8;
            color: white;
            border: none;
            border-radius: 6px;
            font-family: 'Inter', sans-serif;
            font-size: 14px;
            font-weight: 500;
            cursor: pointer;
            white-space: nowrap;
        }
        
        .card-input-wrapper button:hover {
            background: #2847b8;
        }
        
        
        @keyframes slideIn {
            from {
                opacity: 0;
                transform: translateY(-10px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }
        
        .message-card-header {
            background: #f9fafb;
            border-bottom: 1px solid #e5e7eb;
            padding: 14px 20px;
            display: flex;
            align-items: center;
            justify-content: space-between;
        }
        
        .message-question-header {
            display: flex;
            align-items: center;
            gap: 6px;
        }
        
        .message-lightbulb {
            font-size: 13px;
        }
        
        .message-header-text {
            font-family: 'Inter', sans-serif;
            font-size: 15px;
            font-weight: 500;
            color: #374151;
            letter-spacing: -0.02em;
            margin: 0;
        }
        
        .message-card-body {
            padding: 20px;
            background: #ffffff;
        }
        
        .message-card-body .message-content {
            font-family: 'Inter', sans-serif;
            font-size: 15px;
            font-weight: 400;
            color: #374151;
            line-height: 1.7;
            letter-spacing: -0.01em;
            margin-bottom: 16px;
        }
        
        .message-card-body .message-content p {
            margin: 0 0 12px 0;
            font-size: 15px;
            line-height: 1.7;
            color: #374151;
            font-weight: 400;
        }
        
        .message-card-body .message-content p:last-child {
            margin-bottom: 0;
        }
        
        .message-card-footer {
            height: 40px;
            background: repeating-linear-gradient(
                -45deg,
                #e3f2fd,
                #e3f2fd 10px,
                #bbdefb 10px,
                #bbdefb 20px
            );
            position: relative;
            display: flex;
            align-items: center;
            justify-content: flex-end;
            padding: 0 20px;
        }
        
        .message-badge-answered {
            background: #4caf50;
            color: white;
            padding: 4px 12px;
            border-radius: 20px;
            font-size: 11px;
            font-weight: bold;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }
        
        .message-question {
            font-size: 18px;
            font-weight: 600;
            color: #2c3e50;
            margin-bottom: 20px;
            display: flex;
            align-items: center;
            gap: 10px;
        }
        
        .message-question-icon {
            width: 24px;
            height: 24px;
            background: #e3f2fd;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 16px;
        }
        
        .message-content-section {
            margin-bottom: 20px;
        }
        
        .message-content-section:last-child {
            margin-bottom: 0;
        }
        
        .message-content-section h3 {
            font-size: 16px;
            font-weight: 600;
            color: #1f2937;
            margin: 16px 0 12px 0;
            line-height: 1.5;
            letter-spacing: -0.02em;
        }
        
        .message-content-section:first-child h3 {
            margin-top: 0;
        }
        
        .message-content-list {
            list-style: none;
            padding: 0;
            margin: 0;
        }
        
        .message-content-list li {
            padding: 8px 0;
            font-size: 15px;
            color: #374151;
            display: flex;
            align-items: flex-start;
            gap: 10px;
            line-height: 1.7;
            font-weight: 400;
        }
        
        .message-content-list li .emoji {
            font-size: 16px;
            flex-shrink: 0;
        }
        
        .message-content-list li span:not(.emoji) {
            flex: 1;
            font-weight: 400;
            font-size: 15px;
            color: #374151;
        }
        
        .message-decorative-badge {
            background: #2196f3;
            color: white;
            padding: 4px 10px;
            border-radius: 4px;
            font-size: 14px;
            font-weight: bold;
        }
        
        .message-input-section {
            border-top: 1px solid #ecf0f1;
            padding-top: 15px;
            margin-top: 20px;
        }
        
        .message-input-wrapper {
            display: flex;
            align-items: center;
            gap: 10px;
            background: #f8f9fa;
            border: 2px solid #e9ecef;
            border-radius: 8px;
            padding: 12px 15px;
        }
        
        .message-input-icon {
            color: #6c757d;
            font-size: 20px;
            cursor: pointer;
        }
        
        .message-input-text {
            flex: 1;
            border: none;
            background: none;
            outline: none;
            font-size: 15px;
            color: #495057;
            font-family: inherit;
        }
        
        .message-timestamp {
            font-size: 13px;
            color: #9ca3af;
            margin-top: 12px;
            text-align: right;
            font-weight: 400;
        }
        
        /* User message card variant */
        .message-card-redesign.user-message-card .message-card-body {
            padding: 20px;
        }
        
        .message-card-redesign.user-message-card .message-question {
            margin-bottom: 0;
        }
        
        /* Processing state */
        .message-card-redesign.processing .message-badge-answered {
            background: #ff9800;
        }
        
        .message-card-redesign.processing .thinking-indicator {
            color: #ff9800;
            font-style: italic;
        }
        
    </style>
</head>
<body>
    <div class="container">

        
        <!-- Greeting Header -->
        <div class="greeting-header">
            <h1 class="greeting-title" id="dynamicGreeting">Good Morning,<br>Loading...</h1>
            <p class="question-counter" id="questionCounter">Loading status...</p>
            </div>
        
        <div class="main-content">
                <div class="new-session-section">
                <h3>What are you building?</h3>
                <div class="new-session-content">
                    <div class="permission-mode-section">
                        <label for="permissionMode">Permission Mode:</label>
                        <select id="permissionMode">
                            <option value="interactive">Interactive (MCP-based)</option>
                            <option value="acceptEdits">Accept Edits (Auto-approve edits)</option>
                            <option value="default">Default (Claude Code prompts)</option>
                            <option value="bypassPermissions" selected>Bypass All (Dangerous!)</option>
                        </select>
                    </div>
                    <div class="new-session-input">
                        <textarea id="newSessionInput" placeholder="Type your answer here..." rows="1" oninput="autoResizeTextarea(this)"></textarea>
                        <button class="btn btn-success" onclick="startNewSession()" id="newSessionBtn">Send</button>
                    </div>
                    </div>
                </div>
                
                    <div id="sessionsContainer">
                        <div class="empty-state">No sessions yet. Start a new conversation above!</div>
                    </div>
        </div>
    </div>
    
    <script>
       // Configuration
        // Auto-detect API URL based on current host
        function getApiUrl() {
            // Check if we're on ngrok
            if (window.location.hostname.includes('ngrok')) {
                // When on ngrok, use local network IP
                return 'http://192.168.29.186:8001';
            }
            // Default for local development
            return 'http://localhost:8001';
        }
        
        const API_URL = getApiUrl();
        const webhookUrl = `${window.location.protocol}//${window.location.host}/webhook`;
        // Log the configuration
        console.log('API URL:', API_URL);
        console.log('Webhook URL:', webhookUrl);
        
        // State
        let messagesBySession = {};
        let allMessages = [];
        let sessionPermissionModes = {};
        let eventSource = null;
        
        // DOM Elements
        const sessionsContainer = document.getElementById('sessionsContainer');
        const newSessionInput = document.getElementById('newSessionInput');
        const newSessionBtn = document.getElementById('newSessionBtn');
        
        // Polling Functions
        async function pollMessages() {
            try {
                const response = await fetch('/messages');
                if (response.ok) {
                    const data = await response.json();
                    const newMessages = data.messages || [];
                    
                    // Check if messages have actually changed
                    if (JSON.stringify(newMessages) !== JSON.stringify(allMessages)) {
                        // Save current input values and focus
                        const inputStates = saveAllInputStates();
                        
                        allMessages = newMessages;
                        groupMessagesBySession();
                        renderSessions();
                        
                        // Restore input values and focus
                        restoreAllInputStates(inputStates);
                    }
                    
                    updateStatus(true);
                }
            } catch (error) {
                console.error('Error polling messages:', error);
                updateStatus(false);
            }
        }
        
        function groupMessagesBySession() {
            messagesBySession = {};
            
            allMessages.forEach(msg => {
                const groupId = msg.conversation_id || msg.session_id || 'no-session';
                if (!messagesBySession[groupId]) {
                    messagesBySession[groupId] = [];
                }
                messagesBySession[groupId].push(msg);
            });
            
            // Sort messages within each session
            Object.keys(messagesBySession).forEach(sessionId => {
                messagesBySession[sessionId].sort((a, b) => 
                    new Date(a.timestamp) - new Date(b.timestamp)
                );
            });
        }
        
        // Render Functions
        function renderSessions() {
            const newSessionSection = document.querySelector('.new-session-section');
            
            if (Object.keys(messagesBySession).length === 0) {
                // Show new session section when no sessions
                if (newSessionSection) {
                    newSessionSection.style.display = 'block';
                }
                const hour = new Date().getHours();
                let emptyMessage;
                if (hour < 12) {
                    emptyMessage = "Good morning! Ready to start building something amazing?";
                } else if (hour < 17) {
                    emptyMessage = "What would you like to create this afternoon?";
                } else {
                    emptyMessage = "Let's build something great this evening!";
                }
                
                sessionsContainer.innerHTML = `<div class="empty-state">${emptyMessage}</div>`;
                
                // Update dynamic content for empty state
                updateDynamicContent();
                return;
            }
            
            // Hide new session section when there are active sessions
            if (newSessionSection) {
                newSessionSection.style.display = 'none';
            }
            
            // Update dynamic content based on current conversations
            updateDynamicContent();
            
            const sessionIds = Object.keys(messagesBySession).sort((a, b) => {
                const aTime = new Date(messagesBySession[a][0].timestamp);
                const bTime = new Date(messagesBySession[b][0].timestamp);
                return bTime - aTime;
            });
            
            sessionsContainer.innerHTML = sessionIds.map(sessionId => {
                const messages = messagesBySession[sessionId];
                
                return `
                    <div class="session-content-direct" data-session-id="${sessionId}">
                        <div class="horizontal-cards-container" id="cards-container-${sessionId}">
                            ${messages.slice().reverse().map((msg, index) => {
                                const originalIndex = messages.length - 1 - index;
                                return renderMessageCard(msg, messages, originalIndex, sessionId);
                            }).join('')}
                        </div>
                    </div>
                `;
            }).join('');
            
            // Auto-scroll to the latest card (which is now at the beginning)
            sessionIds.forEach(sessionId => {
                const container = document.getElementById(`cards-container-${sessionId}`);
                if (container) {
                    setTimeout(() => {
                        container.scrollLeft = 0; // Scroll to beginning where latest card is
                    }, 100);
                }
            });
        }
        
        // Helper function to format message content with sections and bullet points
        function formatMessageContent(content) {
            if (!content) return '';
            
            // Split content into lines
            const lines = content.split('\n');
            let formattedHTML = '';
            let currentSection = null;
            let currentList = [];
            
            lines.forEach(line => {
                line = line.trim();
                if (!line) return;
                
                // Check if this is a section header (e.g., "Core Infrastructure:", "Content Creation:")
                if (line.endsWith(':') && !line.startsWith('-') && !line.startsWith('•') && !line.startsWith('*')) {
                    // Close previous section if exists
                    if (currentSection || currentList.length > 0) {
                        if (currentList.length > 0) {
                            formattedHTML += '<ul class="message-content-list">' + currentList.join('') + '</ul>';
                            currentList = [];
                        }
                        if (currentSection) {
                            formattedHTML += '</div>';
                        }
                    }
                    
                    // Start new section
                    currentSection = line.slice(0, -1); // Remove the colon
                    formattedHTML += `<div class="message-content-section"><h3>${escapeHtml(currentSection)}</h3>`;
                }
                // Check if this is a bullet point
                else if (line.startsWith('- ') || line.startsWith('• ') || line.startsWith('* ')) {
                    let bulletContent = line.substring(2).trim();
                    // Extract emoji if present at the start
                    const emojiMatch = bulletContent.match(/^([\u{1F300}-\u{1F9FF}]|[\u{2600}-\u{26FF}]|[\u{2700}-\u{27BF}])/u);
                    if (emojiMatch) {
                        const emoji = emojiMatch[0];
                        const text = bulletContent.substring(emoji.length).trim();
                        currentList.push(`<li><span class="emoji">${emoji}</span><span>${escapeHtml(text)}</span></li>`);
                    } else {
                        currentList.push(`<li><span class="emoji">•</span><span>${escapeHtml(bulletContent)}</span></li>`);
                    }
                }
                // Regular paragraph
                else {
                    if (currentList.length > 0) {
                        formattedHTML += '<ul class="message-content-list">' + currentList.join('') + '</ul>';
                        currentList = [];
                    }
                    formattedHTML += `<p>${escapeHtml(line)}</p>`;
                }
            });
            
            // Close any remaining lists or sections
            if (currentList.length > 0) {
                formattedHTML += '<ul class="message-content-list">' + currentList.join('') + '</ul>';
            }
            if (currentSection) {
                formattedHTML += '</div>';
            }
            
            return formattedHTML || `<p>${escapeHtml(content)}</p>`;
        }

        function getMessageQuestionContext(msg, conversationMessages) {
            // Try to extract question context from the message content
            if (msg.result) {
                const content = msg.result;
                
                // Look for explicit question patterns
                if (content.includes('Question 1:') || content.includes('What are you building')) {
                    return "What are you building?";
                } else if (content.includes('Question 2:') || content.includes('Why are we building')) {
                    return "Why are we building this?";
                } else if (content.includes('Question 3:') || content.includes('How should it work')) {
                    return "How should it work?";
                } else if (content.includes('Question 4:') || content.includes('requirements')) {
                    return "What are the requirements?";
                }
            }
            
            // Check conversation context
            const conversationIndex = conversationMessages.indexOf(msg);
            if (conversationIndex > 0) {
                // Look at previous messages for context
                for (let i = conversationIndex - 1; i >= 0; i--) {
                    const prevMsg = conversationMessages[i];
                    if (prevMsg.result) {
                        return getMessageQuestionContext(prevMsg, conversationMessages);
                    }
                }
            }
            
            return "What are you building?";
        }
        
        function getDynamicPlaceholder(msg, conversationMessages) {
            const context = getMessageQuestionContext(msg, conversationMessages);
            
            // Generate contextual placeholder based on the question
            if (context === "What are you building?") {
                return "Tell me more about your project...";
            } else if (context === "Why are we building this?") {
                return "Explain your motivation...";
            } else if (context === "How should it work?") {
                return "Describe the functionality...";
            } else if (context === "What are the requirements?") {
                return "List your requirements...";
            } else {
                return "Continue this conversation...";
            }
        }
        
        function getUserQuestionType(userInput) {
            const input = userInput.toLowerCase();
            
            if (input.includes('want') || input.includes('build') || input.includes('feature')) {
                return "Your Feature Request";
            } else if (input.includes('why') || input.includes('because') || input.includes('purpose')) {
                return "Your Reasoning";
            } else if (input.includes('how') || input.includes('work') || input.includes('implement')) {
                return "Your Implementation Ideas";
            } else if (input.includes('requirement') || input.includes('need') || input.includes('must')) {
                return "Your Requirements";
            }
            
            return "Your Input";
        }

        function renderMessageCard(msg, conversationMessages = [], index, sessionId) {
            const messageType = msg.message_type || 'legacy';
            const status = msg.status || 'unknown';
            const isLatestMessage = index === conversationMessages.length - 1;
            
            // Add input section only to the latest message card
            const inputSection = isLatestMessage ? `
                <div class="card-input-section">
                    <div class="card-input-wrapper">
                        <textarea 
                            id="card-input-${sessionId}-${index}" 
                            placeholder="${getDynamicPlaceholder(msg, conversationMessages)}"
                            rows="1"
                            onkeydown="handleCardKeyDown(event, '${sessionId}')"
                            oninput="autoResizeTextarea(this)"
                        ></textarea>
                        <button onclick="sendQueryFromCard('${sessionId}')">
                            Send
                        </button>
                    </div>
                </div>
            ` : '';
            
            const cardContent = renderMessageWithInput(msg, conversationMessages, inputSection);
            
            return `
                <div class="message-card-wrapper ${isLatestMessage ? 'active' : 'inactive'}" data-index="${index}">
                    ${cardContent}
                </div>
            `;
        }
        
        function renderMessageWithInput(msg, conversationMessages, inputSection) {
            const messageType = msg.message_type || 'legacy';
            const status = msg.status || 'unknown';
            
            // Handle different message types with new design
            if (messageType === 'user') {
                const userQuestionType = getUserQuestionType(msg.result || msg.prompt || '');
                
                return `
                    <div class="message-card-redesign user-message-card">
                        <div class="message-card-header">
                            <div class="message-question-header">
                                <span class="message-lightbulb">💡</span>
                                <h4 class="message-header-text">${userQuestionType}</h4>
                            </div>
                        </div>
                        <div class="message-card-body">
                            <div class="message-content">
                                ${formatMessageContent(msg.result || msg.prompt || '')}
                            </div>
                            <div class="message-timestamp" style="font-size: 13px; color: #9ca3af; text-align: right; font-weight: 400;">
                                ${new Date(msg.timestamp).toLocaleString()}
                            </div>
                            ${inputSection}
                        </div>
                    </div>
                `;
            } else if (messageType === 'claude_processing') {
                const questionContext = getMessageQuestionContext(msg, conversationMessages);
                
                return `
                    <div class="message-card-redesign processing">
                        <div class="message-card-header">
                            <div class="message-question-header">
                                <span class="message-lightbulb">💡</span>
                                <h4 class="message-header-text">${questionContext}</h4>
                            </div>
                        </div>
                        <div class="message-card-body">
                            <div class="thinking-indicator" style="font-style: italic; margin-bottom: 10px;">Claude is thinking...</div>
                            ${msg.result ? `<div class="message-content">${formatMessageContent(msg.result)}</div>` : ''}
                            <div class="message-timestamp" style="font-size: 13px; color: #9ca3af; text-align: right; font-weight: 400;">
                                ${new Date(msg.timestamp).toLocaleString()}
                            </div>
                            ${inputSection}
                        </div>
                    </div>
                `;
            } else if (messageType === 'claude_completed') {
                const questionContext = getMessageQuestionContext(msg, conversationMessages);
                
                return `
                    <div class="message-card-redesign">
                        <div class="message-card-header">
                            <div class="message-question-header">
                                <span class="message-lightbulb">💡</span>
                                <h4 class="message-header-text">${questionContext}</h4>
                            </div>
                        </div>
                        <div class="message-card-body">
                            <div class="message-content">
                            ${formatMessageContent(msg.result || '')}
                                </div>
                            <div class="message-timestamp" style="font-size: 13px; color: #9ca3af; text-align: right; font-weight: 400;">
                                ${new Date(msg.timestamp).toLocaleString()}
                            </div>
                            ${inputSection}
                        </div>
                    </div>
                `;
            } else {
                // Default/legacy format - render using the original renderMessage function
                return renderMessage(msg, conversationMessages);
            }
        }
        
        function scrollToCard(sessionId, index) {
            const container = document.getElementById(`cards-container-${sessionId}`);
            const cards = container.querySelectorAll('.message-card-wrapper');
            const messages = messagesBySession[sessionId];
            const reversedIndex = messages.length - 1 - index;
            const targetCard = cards[reversedIndex];
            
            if (targetCard) {
                // Update active states
                cards.forEach(card => {
                    card.classList.remove('active');
                    card.classList.add('inactive');
                });
                targetCard.classList.remove('inactive');
                targetCard.classList.add('active');
                
                // Update navigation dots
                const dots = container.parentElement.querySelectorAll('.nav-dot');
                dots.forEach((dot, i) => {
                    dot.classList.toggle('active', messages.length - 1 - i === index);
                });
                
                // Scroll to the card
                targetCard.scrollIntoView({ behavior: 'smooth', block: 'nearest', inline: 'center' });
            }
        }
        
        function autoResizeTextarea(textarea) {
            textarea.style.height = 'auto';
            textarea.style.height = Math.min(textarea.scrollHeight, 120) + 'px';
        }
        
        function handleCardKeyDown(event, sessionId) {
            if (event.key === 'Enter' && !event.shiftKey) {
                event.preventDefault();
                sendQueryFromCard(sessionId);
            }
        }
        
        async function sendQueryFromCard(sessionId) {
            const messages = messagesBySession[sessionId];
            const latestIndex = messages.length - 1;
            const input = document.getElementById(`card-input-${sessionId}-${latestIndex}`);
            const prompt = input ? input.value.trim() : '';
            
            if (!prompt) {
                showNotification('Please enter a message', 'error');
                return;
            }
            
            const latestSessionId = messages[latestIndex].session_id;
            const permissionMode = sessionPermissionModes[sessionId] || 'bypassPermissions';
            
            try {
                const response = await fetch(`${API_URL}/query`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        prompt: prompt,
                        webhook_url: webhookUrl,
                        session_id: latestSessionId,
                        conversation_id: sessionId,
                        options: { permission_mode: permissionMode }
                    })
                });
                
                if (response.ok) {
                    input.value = '';
                    showNotification('Query sent', 'success');
                    
                    // Track message sent
                    trackEvent('message_sent', {
                        conversation_id: sessionId,
                        permission_mode: permissionMode,
                        message_length: prompt.length
                    });
                } else {
                    throw new Error('Failed to send query');
                }
            } catch (error) {
                showNotification('Failed to send query', 'error');
                
                // Track error
                trackEvent('message_send_error', {
                    conversation_id: sessionId,
                    error_message: error.message
                });
            }
        }
        
        function renderMessage(msg, conversationMessages = []) {
            const messageType = msg.message_type || 'legacy';
            const status = msg.status || 'unknown';
            
            // Handle different message types with new design
            if (messageType === 'user') {
                const userQuestionType = getUserQuestionType(msg.result || msg.prompt || '');
                
                return `
                    <div class="message-card-redesign user-message-card">
                        <div class="message-card-header">
                            <div class="message-question-header">
                                <span class="message-lightbulb">💡</span>
                                <h4 class="message-header-text">${userQuestionType}</h4>
                            </div>
                        </div>
                        <div class="message-card-body">
                            <div class="message-content">
                                ${formatMessageContent(msg.result || msg.prompt || '')}
                            </div>
                            <div class="message-timestamp" style="font-size: 13px; color: #9ca3af; text-align: right; font-weight: 400;">
                                ${new Date(msg.timestamp).toLocaleString()}
                            </div>
                        </div>
                    </div>
                `;
            } else if (messageType === 'claude_processing') {
                const questionContext = getMessageQuestionContext(msg, conversationMessages);
                
                return `
                    <div class="message-card-redesign processing">
                        <div class="message-card-header">
                            <div class="message-question-header">
                                <span class="message-lightbulb">💡</span>
                                <h4 class="message-header-text">${questionContext}</h4>
                            </div>
                        </div>
                        <div class="message-card-body">
                            <div class="thinking-indicator" style="font-style: italic; margin-bottom: 10px;">Claude is thinking...</div>
                            ${msg.result ? `<div class="message-content">${formatMessageContent(msg.result)}</div>` : ''}
                            <div class="message-timestamp" style="font-size: 13px; color: #9ca3af; text-align: right; font-weight: 400;">
                                ${new Date(msg.timestamp).toLocaleString()}
                            </div>
                        </div>
                    </div>
                `;
            } else if (messageType === 'claude_completed') {
                const questionContext = getMessageQuestionContext(msg, conversationMessages);
                
                return `
                    <div class="message-card-redesign">
                        <div class="message-card-header">
                            <div class="message-question-header">
                                <span class="message-lightbulb">💡</span>
                                <h4 class="message-header-text">${questionContext}</h4>
                            </div>
                        </div>
                        <div class="message-card-body">
                            <div class="message-content">
                            ${formatMessageContent(msg.result || '')}
                                </div>
                            <div class="message-timestamp" style="font-size: 13px; color: #9ca3af; text-align: right; font-weight: 400;">
                                ${new Date(msg.timestamp).toLocaleString()}
                            </div>
                        </div>
                    </div>
                `;
            } else if (status === 'failed') {
                return `
                    <div class="message-card-redesign">
                        <div class="message-card-header">
                            <div class="message-question-header">
                                <span class="message-lightbulb">⚠️</span>
                                <h4 class="message-header-text" style="color: #f44336;">Error Occurred</h4>
                            </div>
                        </div>
                        <div class="message-card-body">
                            <div class="message-content" style="color: #dc2626;">
                                ${formatMessageContent(msg.error || msg.result || 'Unknown error')}
                            </div>
                            <div class="message-timestamp" style="font-size: 13px; color: #9ca3af; text-align: right; font-weight: 400;">
                                ${new Date(msg.timestamp).toLocaleString()}
                            </div>
                        </div>
                    </div>
                `;
            } else {
                // Legacy message format (fallback) - also use new design
                const isUserMessage = msg.prompt !== undefined;
                
                if (isUserMessage && msg.prompt) {
                    const userQuestionType = getUserQuestionType(msg.prompt);
                    
                    return `
                        <div class="message-card-redesign user-message-card">
                            <div class="message-card-header">
                                <div class="message-question-header">
                                    <span class="message-lightbulb">💡</span>
                                    <h4 class="message-header-text">${userQuestionType}</h4>
                                </div>
                            </div>
                            <div class="message-card-body">
                                <div class="message-content">
                                    ${formatMessageContent(msg.prompt)}
                                </div>
                                <div class="message-timestamp" style="font-size: 13px; color: #9ca3af; text-align: right; font-weight: 400;">
                                    ${new Date(msg.timestamp).toLocaleString()}
                                </div>
                            </div>
                        </div>
                    `;
                } else if (msg.result) {
                    const questionContext = getMessageQuestionContext(msg, conversationMessages);
                    
                    return `
                        <div class="message-card-redesign">
                            <div class="message-card-header">
                                <div class="message-question-header">
                                    <span class="message-lightbulb">💡</span>
                                    <h4 class="message-header-text">${questionContext}</h4>
                                </div>
                                </div>
                            <div class="message-card-body">
                                <div class="message-content">
                                ${formatMessageContent(msg.result)}
                                    </div>
                                <div class="message-timestamp" style="font-size: 13px; color: #9ca3af; text-align: right; font-weight: 400;">
                                    ${new Date(msg.timestamp).toLocaleString()}
                                </div>
                            </div>
                        </div>
                    `;
                }
                
                return ''; // Return empty for unhandled cases
            }
        }
        
        // Action Functions
        async function startNewSession() {
            const prompt = newSessionInput.value.trim();
            if (!prompt) {
                showNotification('Please enter a message', 'error');
                return;
            }
            
            const permissionMode = document.getElementById('permissionMode').value;
            const conversationId = `conv-${Date.now()}`;
            
            newSessionBtn.disabled = true;
            newSessionBtn.textContent = 'Starting...';
            
            try {
                const response = await fetch(`${API_URL}/query`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        prompt: prompt,
                        webhook_url: webhookUrl,
                        conversation_id: conversationId,
                        options: { permission_mode: permissionMode }
                    })
                });
                
                if (response.ok) {
                    sessionPermissionModes[conversationId] = permissionMode;
                    newSessionInput.value = '';
                    showNotification('Session started successfully', 'success');
                    
                    // Track new session creation
                    trackEvent('new_session_started', {
                        permission_mode: permissionMode,
                        conversation_id: conversationId
                    });
                    
                    setTimeout(() => {
                        pollMessages();
                        newSessionBtn.textContent = 'Start New Session';
                        newSessionBtn.disabled = false;
                    }, 1000);
                } else {
                    const errorText = await response.text();
                    console.error('API Error:', response.status, errorText);
                    throw new Error(`API Error ${response.status}: ${errorText}`);
                }
            } catch (error) {
                console.error('Failed to start session:', error);
                showNotification(`Failed: ${error.message}`, 'error');
                
                // Track session start error
                trackEvent('session_start_error', {
                    permission_mode: permissionMode,
                    error_message: error.message
                });
                
                newSessionBtn.textContent = 'Start New Session';
                newSessionBtn.disabled = false;
            }
        }
        
        async function sendQueryToSession(conversationId) {
            const input = document.getElementById(`input-${conversationId}`);
            const prompt = input.value.trim();
            
            if (!prompt) {
                showNotification('Please enter a message', 'error');
                return;
            }
            
            const conversationMessages = messagesBySession[conversationId] || [];
            const latestSessionId = conversationMessages.length > 0 
                ? conversationMessages[conversationMessages.length - 1].session_id 
                : null;
            
            const permissionMode = sessionPermissionModes[conversationId] || 'bypassPermissions';
            
            try {
                const response = await fetch(`${API_URL}/query`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        prompt: prompt,
                        webhook_url: webhookUrl,
                        session_id: latestSessionId,
                        conversation_id: conversationId,
                        options: { permission_mode: permissionMode }
                    })
                });
                
                if (response.ok) {
                    input.value = '';
                    showNotification('Query sent', 'success');
                    
                    // Track message sent
                    trackEvent('message_sent', {
                        conversation_id: conversationId,
                        permission_mode: permissionMode,
                        message_length: prompt.length
                    });
                } else {
                    throw new Error('Failed to send query');
                }
            } catch (error) {
                showNotification('Failed to send query', 'error');
                
                // Track error
                trackEvent('message_send_error', {
                    conversation_id: conversationId,
                    error_message: error.message
                });
            }
        }
        
        // Helper Functions
        function saveAllInputStates() {
            const states = {};
            const focusedElement = document.activeElement;
            
            // Save focused element info
            if (focusedElement && focusedElement.id) {
                states.focusedElementId = focusedElement.id;
            }
            
            // Save all input values
            document.querySelectorAll('textarea').forEach(input => {
                if (input.id) {
                    states[input.id] = {
                        value: input.value,
                        selectionStart: input.selectionStart,
                        selectionEnd: input.selectionEnd
                    };
                }
            });
            
            return states;
        }
        
        function restoreAllInputStates(states) {
            if (!states) return;
            
            // Restore input values
            Object.entries(states).forEach(([key, value]) => {
                if (key !== 'focusedElementId' && typeof value === 'object') {
                    const input = document.getElementById(key);
                    if (input && value) {
                        input.value = value.value || '';
                        if (value.selectionStart !== null && value.selectionEnd !== null) {
                            try {
                                input.setSelectionRange(value.selectionStart, value.selectionEnd);
                            } catch (e) {
                                // Ignore selection range errors
                            }
                        }
                    }
                }
            });
            
            // Restore focus
            if (states.focusedElementId) {
                const elementToFocus = document.getElementById(states.focusedElementId);
                if (elementToFocus) {
                    elementToFocus.focus();
                }
            }
        }
        

        
        function handleKeyDown(event, sessionId) {
            if (event.key === 'Enter' && !event.shiftKey) {
                event.preventDefault();
                sendQueryToSession(sessionId);
            }
        }
        
        function escapeHtml(text) {
            const div = document.createElement('div');
            div.textContent = text;
            return div.innerHTML;
        }
        
        function updateStatus(connected) {
            // Status display removed, keeping function for compatibility
            
            // Track connection status changes
            trackEvent('connection_status_change', {
                connected: connected,
                timestamp: new Date().toISOString()
            });
        }
        
        function showNotification(message, type = 'info') {
            const notification = document.createElement('div');
            notification.className = `notification ${type}`;
            notification.textContent = message;
            document.body.appendChild(notification);
            
            setTimeout(() => {
                notification.remove();
            }, 3000);
        }
        
        // SSE Setup
        function setupSSE() {
            eventSource = new EventSource('/events');
            
            eventSource.onopen = () => {
                console.log('SSE connection established');
                updateStatus(true);
            };
            
            eventSource.onerror = (error) => {
                console.error('SSE error:', error);
                updateStatus(false);
                setTimeout(setupSSE, 5000);
                eventSource.close();
            };
            
            eventSource.onmessage = (event) => {
                try {
                    const data = JSON.parse(event.data);
                    
                    if (data.type === 'webhook') {
                            // Only poll if not actively typing
                            if (document.activeElement?.tagName !== 'TEXTAREA') {
                                pollMessages();
                            } else {
                                // Mark that we need to update when done typing
                                window.pendingMessageUpdate = true;
                            }
                    }
                } catch (error) {
                    console.error('Error processing SSE message:', error);
                }
            };
        }
        
        // Keyboard shortcut for new session
        newSessionInput.addEventListener('keydown', (e) => {
            if (e.key === 'Enter' && !e.shiftKey) {
                e.preventDefault();
                startNewSession();
            }
        });
        
        // Update messages when textarea loses focus
        document.addEventListener('blur', (e) => {
            if (e.target.tagName === 'TEXTAREA' && window.pendingMessageUpdate) {
                window.pendingMessageUpdate = false;
                setTimeout(() => {
                    pollMessages();
                }, 100);
            }
        }, true);
        
        // Dynamic Data Functions
        function getDynamicGreeting() {
            const hour = new Date().getHours();
            const userName = getUserName();
            
            let timeGreeting;
            if (hour < 12) {
                timeGreeting = "Good Morning";
            } else if (hour < 17) {
                timeGreeting = "Good Afternoon";
            } else {
                timeGreeting = "Good Evening";
            }
            
            return `${timeGreeting},<br>${userName}.`;
        }
        
        function getUserName() {
            // Try to get user name from various sources
            const savedName = localStorage.getItem('userName');
            if (savedName) return savedName;
            
            // Try to extract from git config or system
            const gitUser = localStorage.getItem('gitUserName');
            if (gitUser) return gitUser;
            
            // Get from browser/system if available
            if (navigator.userAgentData && navigator.userAgentData.platform) {
                return 'Developer'; // Fallback for privacy
            }
            
            // Default fallback
            return 'Developer';
        }
        
        function updateQuestionCounter() {
            const pendingQuestions = countPendingQuestions();
            const activeConversations = Object.keys(messagesBySession).length;
            
            let counterText;
            if (pendingQuestions > 0) {
                counterText = `You have ${pendingQuestions} question${pendingQuestions === 1 ? '' : 's'} to answer.`;
            } else if (activeConversations > 0) {
                counterText = `${activeConversations} active conversation${activeConversations === 1 ? '' : 's'}.`;
            } else {
                counterText = "Ready to start a new conversation.";
            }
            
            document.getElementById('questionCounter').textContent = counterText;
        }
        
        function countPendingQuestions() {
            let pendingCount = 0;
            
            Object.values(messagesBySession).forEach(messages => {
                const lastMessage = messages[messages.length - 1];
                if (lastMessage && (lastMessage.status === 'processing' || lastMessage.message_type === 'claude_processing')) {
                    pendingCount++;
                }
            });
            
            return pendingCount;
        }
        
        function getCurrentQuestionContext() {
            // Determine what question should be shown based on conversation state
            const hasActiveConversations = Object.keys(messagesBySession).length > 0;
            
            if (!hasActiveConversations) {
                return "What are you building?";
            }
            
            // If there are conversations, check the latest context
            const allMessages = Object.values(messagesBySession).flat();
            const lastMessage = allMessages[allMessages.length - 1];
            
            if (lastMessage && lastMessage.result) {
                // Extract question context from the last Claude response
                const result = lastMessage.result;
                if (result.includes('Question 2:')) {
                    return "Why are we building this?";
                } else if (result.includes('Question 3:')) {
                    return "How should it work?";
                } else if (result.includes('Question 4:')) {
                    return "What are the requirements?";
                }
            }
            
            return "What are you building?";
        }
        
        function updateDynamicContent() {
            // Update greeting
            document.getElementById('dynamicGreeting').innerHTML = getDynamicGreeting();
            
            // Update question counter
            updateQuestionCounter();
            
            // Update current question context
            const questionHeader = document.querySelector('.new-session-section h3');
            if (questionHeader) {
                questionHeader.textContent = getCurrentQuestionContext();
            }
        }

        // Firebase Analytics Helper Functions
        function trackEvent(eventName, parameters = {}) {
            if (window.firebaseAnalytics) {
                import('https://www.gstatic.com/firebasejs/10.7.1/firebase-analytics.js')
                    .then(({ logEvent }) => {
                        logEvent(window.firebaseAnalytics, eventName, parameters);
                        console.log(`Firebase Analytics: ${eventName}`, parameters);
                    })
                    .catch(error => console.error('Analytics tracking error:', error));
            }
        }
        
        // Track page view
        trackEvent('page_view', {
            page_title: 'Claude Code Dashboard',
            page_location: window.location.href
        });
        
        // Initialize dynamic user name on first visit
        function initializeUserName() {
            if (!localStorage.getItem('userName')) {
                const userName = prompt('Welcome! What should we call you?', 'Developer');
                if (userName && userName.trim()) {
                    localStorage.setItem('userName', userName.trim());
                }
            }
        }
        
        // Initialize everything
        initializeUserName();
        updateDynamicContent();
        pollMessages();
        setupSSE();
        
        // Periodic polling as backup
        setInterval(() => {
            // Only poll if document is visible and not actively typing
            if (!document.hidden && document.activeElement?.tagName !== 'TEXTAREA') {
                pollMessages();
            }
        }, 5000);
        
        // Update dynamic content every minute to keep greeting current
        setInterval(() => {
            updateDynamicContent();
        }, 60000);
        
        // Also poll when switching back to tab
        document.addEventListener('visibilitychange', () => {
            if (!document.hidden) {
                pollMessages();
            }
        });
    </script>
</body>
</html>